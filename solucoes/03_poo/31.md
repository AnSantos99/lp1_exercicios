## Pergunta

31 - Considera o seguinte código:

```cs
public abstract class GameObject
{
    public float X { get; protected set; }
    public float Y { get; protected set; }
    public abstract int Priority();
    public virtual bool IsActive() { return true; }
}
```

```cs
public class Trap : GameObject
{
    public override int Priority() { return int.MaxValue; }
    public void DisableTrap() { Console.WriteLine("Trap is now disabled."); }
}
```

```cs
public interface ITaggable
{
    string Tag { get; set; }
}
```

Responde às seguintes questões (neste exercício aceitam-se soluções separadas
a cada uma destas questões):

1. Apresenta o código da classe `PowerUp` que estende `GameObject` e implementa
   a interface `ITaggable`. A prioridade deve ser igual ao comprimento da
   *tag*. Deves sobrepor o método `IsActive()` de modo a retorne `false` se a
   *tag* for `null` ou com comprimento igual a zero, e `true` caso contrário.
2. Sobrepõe o método `ToString()` na classe `PowerUp` de modo a que devolva uma
   *string* que inclua `X` , `Y` e `Tag`. Os números reais devem aparecer com 2
   dígitos significativos.
3. Se `armorPack` for uma instância da classe `PowerUp`, qual a instrução que
   define o valor da sua *tag* como "Armor+75"?
4. Indica, justificando, quais das seguintes instruções são válidas e quais são
   inválidas. As instruções são independentes umas das outras, e naquelas que
   não implicam criação de objetos presume-se que o(s) objeto(s) em questão já
   foram instanciados. Assume que todas as instruções ocorrem fora das classes
   discutidas até ao momento.

```cs
// Instrução 1
PowerUp pu = new PowerUp();
```

```cs
// Instrução 2
GameObject go = new GameObject();
```

```cs
// Instrução 3
Trap t = new Trap();
```

```cs
// Instrução 4
ITaggable it = new ITaggable();
```

```cs
// Instrução 5
go.DisableTrap(); // go é uma variável do tipo GameObject
```

```cs
// Instrução 6
PowerUp armorPack = new GameObject();
```

```cs
// Instrução 7
int p = gobj.DisableTrap; // gobj é do tipo Trap
```

```cs
// Instrução 8
Console.WriteLine($“{trap.Tag}”); // trap é uma instância de Trap
```

```cs
// Instrução 9
GameObject go = new Trap();
```

```cs
// Instrução 10
GameObject go = new PowerUp();
```

```cs
// Instrução 11
Console.WriteLine($“{pup.Priority}”); // pup é uma instância de PowerUp
```

## Soluções

### Solução 1
```CSharp
namespace Ex31_Poo
{
    class PowerUp : GameObject, ITaggable
    {

        public string Tag { get; set; }

        public override int Priority()
        {
            return Tag.Length;
        }

        public override bool IsActive()
        {
            return Priority() > 0 ? true : false;
        }
    }
}
```

### Solução 2
```CSharp
namespace Ex31_Poo
{
    class PowerUp : GameObject, ITaggable
    {

        public string Tag { get; set; }

        public override int Priority()
        {
            return Tag.Length;
        }

        public override bool IsActive()
        {
            return Priority() > 0 ? true : false;
        }

        public override string ToString()
        {
            return $"X Pos: {X:2f} Y Pos: {Y:2f} Name: {Tag}";
        }
    }
}
```

### Solução 3
Sendo um `PowerUp` um `ITaggable` e a propriedade `Tag` ser uma propriedade
autoimplementada com `get` e `set`, o único comando necessário para ater uma
instância de `PowerUP` com a *tag* igual a "Armor+75" seria `pu.Tag = "Armor+75"`
(para uma instância de `PowerUp` chamada `pu`).

### Solução 4
  1. Válida - Apenas estamos a instanciar um objeto do tipo `PowerUp`, como esta
classe não requer nenhum argumento obrigatório no contrutor e não foi delcarada com
modificadores de herança, pode ser instanciada da forma apresentada.
  2. Inválida - É impossível instanciar um objeto de classe declarada com modificador de
herança `abstract`.
  3. Válida - Apenas estamos a instanciar um objeto do tipo `Trap`, como esta
classe não requer nenhum argumento obrigatório no contrutor e não foi delcarada com
modificadores de herança, pode ser instanciada da forma apresentada.
  4. Inválida - Interfaces não podem ser instanciadas, estas servem únicamente para
serem implementadas, ou extendidas por outras interfaces.
  5. Inválida - O método `DisableTrap()` pertence apenas à extensão `Trap` de `GameObject`
não sendo possível chamar o método de uma variável desse tipo, no entanto poderia-se usar
a keyword `as` para usar esse *game object* como se fosse do tipo `Trap`.
  6. Inválida - Ao instanciar um objeto não podemos chamar o construtor da classe Pai
do objeto, no entanto o contrário seria possível.
  7. Inválida - O método `DisableTrap` não tem qualquer valor de retorno, sendo
esta do tipo `void`, logo não seria possível igualar o inteiro p à função.
  8. Inválida - A instância `trap` sendo do tipo `Trap` não possui qualquer propriedade
`Tag`,por sua vez `Trap` não é um `ITaggable`.
  9. Válida - `Trap` é uma extensão de `GameObject` logo pode ser instânciada
como tál, usando o seu próprio construtor.
  10. Válida - `PowerUp` é uma extensão de `GameObject` logo pode ser instânciada
como tál, usando o seu próprio construtor.
  11. Inválido - Embora `PowerUp` tenha o método `Priority()` não contém a
propriedade `Priority`.