## Pergunta

2 - Considera o diagrama UML em baixo, e depois indica, justificando, quais das
seguintes instruções são válidas e quais são inválidas. As instruções são
independentes umas das outras, e naquelas que não implicam criação de objetos
presume-se que o(s) objeto(s) em questão já foram instanciados. Considera-se
que todas as instruções ocorrem fora das classes presentes no diagrama.

![uml02](../../img/uml02.png)

* `Animal animal = new Dog();`
* `Cat cat = new Dog();`
* `Cat cat = new Animal();`
* `a.Bark(); // 'a' é uma instância de Animal`
* `dog.Eat(); // 'dog' é uma instância de Dog`
* `float y = tareco.energy; // 'tareco' é uma instância de Cat`
* `Console.WriteLine(myCat.Name); // 'myCat' é uma instância de Cat`
* `bobi.energy = 123.4f; // 'bobi' é uma instância de 'Dog'`
* `Dog pluto = new Animal();`
* `y.Meow(); // 'y' é uma instância de Cat`
* `beast.Bite(); // 'beast' é uma instância de Animal`
* `zz.Eat(); // 'zz' é uma instância de Cat`

## Soluções

### Solução 1

* `Animal animal = new Dog();`

Válida. Pos, estamos a criar uma variável de tipo `Animal` para instanciar um
objeto tipo `Dog`. Isto é possível porque `Dog` *é* um `Animal`, sendo assim
possível guardar uma instância de `Dog` em uma variável de tipo `Animal`.

* `Cat cat = new Dog();`

Inválida. Esta instrução cria uma variável de tipo `Cat` para instanciar um
objeto tipo `Dog`, mas isto não é possível porque `Dog` *não é* um `Cat`, sendo
assim, não é possível guardar uma instância de `Dog` em uma variável de tipo
`Cat`.

* `Cat cat = new Animal();`

Inválida. Tal como na instrução anterior, criar uma variável de tipo `Cat` para
guardar uma instância de objeto tipo `Animal`, que acaba por ser impossível,
pois que `Cat` herda da classe base `Animal`.

* `a.Bark(); // 'a' é uma instância de Animal`

Inválida. `Animal` não contém o método `Bark()`.

* `dog.Eat(); // 'dog' é uma instância de Dog`

Válida. `Dog` têm o método `Eat()` derivado da classe base `Animal`.

* `float y = tareco.energy; // 'tareco' é uma instância de Cat`

Inválida. A variável `energy` é de tipo **Protected**, sendo impossível aceder
através de uma instância de `Cat`.

* `Console.WriteLine(myCat.Name); // 'myCat' é uma instância de Cat`

Válida. É possível. A variável `name` vem da classe base `Animal`.

* `bobi.energy = 123.4f; // 'bobi' é uma instância de 'Dog'`

Inválida. A variável `energy` é de tipo **Protected**, sendo impossível aceder
através de uma instância de `Dog`.

* `Dog pluto = new Animal();`

Inválida. Este caso é igual ao caso anterior de `Cat cat = new Animal();`. A
variável a ser criada de tipo `Dog` tenta instanciar um objeto tipo `Animal`,
que acaba por ser impossível sendo que não se pode guardar um objeto tipo
`Animal` em uma variável tipo `Dog`, pois que `Dog` herda de `Animal`.

* `y.Meow(); // 'y' é uma instância de Cat`

Válida. O método `Meow()` está contido na classe `Cat`.

* `beast.Bite(); // 'beast' é uma instância de Animal`

Inválida. A classe `Animal` não contém o método `Bite()`.

* `zz.Eat(); // 'zz' é uma instância de Cat`

Válida. O método `Eat()` é derivado da classe base `Animal`.

*Por [Inácio Amerio](https://github.com/FPTheFluffyPawed)*
